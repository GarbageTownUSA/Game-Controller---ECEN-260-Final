<!DOCTYPE html>
<html>
<head>
<title>Game Controller Project Report.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="game-controller-project-report">Game Controller Project Report</h1>
<h2 id="overview-and-introduction">Overview and Introduction</h2>
<p>This project demonstrates a prototype joystick-controlled object movement system using a microcontroller. The project integrates UART communication, ADC (Analog-to-Digital Conversion), and interrupt handling to create a dynamic system capable of interacting with both a graphical display and external devices (e.g., a laptop). The joystick inputs control the movement of an object on a display, and button inputs toggle the state of the object. Responses are transmitted to a connected laptop via UART communication, allowing real-time updates and feedback.</p>
<p>The system provides an intuitive way to control objects, with applications in gaming, industrial control systems, and robotics, making it an excellent starting point for a marketable solution.</p>
<h2 id="design">Design</h2>
<p>The primary purpose of this project is to meet the need for an intuitive object control system that can integrate with external devices. The joystick provides analog control for moving an object on a display, while the button toggles states. This setup serves as a proof of concept for systems such as remote-controlled devices, input controllers, and robotic navigation.</p>
<h3 id="public-health-safety-and-welfare">Public Health, Safety, and Welfare</h3>
<p>Proper grounding techniques and shielded connections are used to reduce electrical noise, ensuring signal integrity for ADC inputs and UART communication. These measures enhance overall system stability, reduce the likelihood of errors, and contribute to long-term operational safety.</p>
<h3 id="global-cultural-and-social-factors">Global, Cultural, and Social Factors</h3>
<p>As an affordable and flexible prototype, the design can be adapted globally for applications in gaming, education, and automation, providing a low-cost, accessible solution for various communities.</p>
<h3 id="environmental-and-economic-factors">Environmental and Economic Factors</h3>
<p>The system uses readily available, low-power components, reducing its environmental impact. The use of ADC inputs minimizes power consumption while maintaining performance.</p>
<h3 id="integrated-course-concepts">Integrated Course Concepts</h3>
<ul>
<li>
<p><strong>ADC</strong>: Used to convert joystick analog input to usable digital values.</p>
</li>
<li>
<p><strong>Interrupts</strong>: Handle button presses efficiently, with debouncing logic.</p>
</li>
<li>
<p><strong>UART Communication</strong>: Transmit responses to a connected laptop for real-time feedback.</p>
</li>
<li>
<p><strong>Display</strong>: Provides visual feedback for joystick movements and object states.</p>
</li>
<li>
<p><strong>Timers</strong>: Used to periodically update ADC readings and display states.</p>
</li>
</ul>
<p>These concepts collectively contribute to a system that is efficient, responsive, and capable of meeting user needs.</p>
<h2 id="specifications">Specifications</h2>
<h3 id="technical-details">Technical Details</h3>
<ul>
<li>
<p><strong>Microcontroller</strong>: STM32 series (e.g., STM32F103).</p>
</li>
<li>
<p><strong>Joystick Input</strong>: Two analog inputs for X and Y axes using ADC channels.</p>
</li>
<li>
<p><strong>Button Input</strong>: GPIO interrupt for toggling object state.</p>
</li>
<li>
<p><strong>Display</strong>: GLCD (Graphic LCD) for visual output.</p>
</li>
<li>
<p><strong>Communication</strong>: UART for transmitting feedback to a connected laptop.</p>
</li>
</ul>
<h3 id="use-cases-and-operating-instructions">Use Cases and Operating Instructions</h3>
<ul>
<li>
<p><strong>Joystick Movement</strong>:</p>
<ul>
<li>
<p>Move the joystick to control the object's position on the display.</p>
</li>
<li>
<p>The system responds with messages like &quot;Moving left...&quot;, &quot;Moving right...&quot;, etc.</p>
</li>
</ul>
</li>
<li>
<p><strong>Wall Limits</strong>:</p>
<ul>
<li>When the object reaches the display edge, messages like &quot;Hit the wall on the left...&quot; are shown.</li>
</ul>
</li>
<li>
<p><strong>Button State Toggle</strong>:</p>
<ul>
<li>
<p>Press the button to toggle between two object states (e.g., 0 and 1).</p>
</li>
<li>
<p>Feedback is transmitted via UART (e.g., &quot;Changed state to 1...&quot;).</p>
</li>
</ul>
</li>
<li>
<p><strong>Feedback Transmission</strong>:</p>
<ul>
<li>Real-time updates are displayed in a terminal application (e.g., PuTTY) on the laptop.</li>
</ul>
</li>
</ul>
<h3 id="operating-constraints">Operating Constraints</h3>
<ul>
<li>
<p><strong>Power Supply</strong>: 3.3V or 5V for the microcontroller and peripherals.</p>
</li>
<li>
<p><strong>Joystick Range</strong>: ADC range of 0-4095 mapped to movement thresholds.</p>
</li>
<li>
<p><strong>Button Debounce Delay</strong>: Minimum of 200 ms to prevent false triggers.</p>
</li>
</ul>
<h3 id="design-limitations">Design Limitations</h3>
<ul>
<li>
<p>The system assumes stable power and reliable communication.</p>
</li>
<li>
<p>The joystick movement is constrained to the screen size (e.g., 75x5 grid).</p>
</li>
<li>
<p>Limited UART bandwidth for continuous updates.</p>
</li>
</ul>
<h3 id="parts-list">Parts List</h3>
<table>
<thead>
<tr>
<th>Component</th>
<th>Quantity</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>STM32 Microcontroller</td>
<td>1</td>
<td>Core processing unit</td>
</tr>
<tr>
<td>Joystick Module</td>
<td>1</td>
<td>X and Y axis analog input</td>
</tr>
<tr>
<td>Push Button</td>
<td>1</td>
<td>Interrupt input for state</td>
</tr>
<tr>
<td>GLCD Display</td>
<td>1</td>
<td>Visual output</td>
</tr>
<tr>
<td>Wires and Breadboard</td>
<td>As needed</td>
<td>Connections and prototyping</td>
</tr>
</tbody>
</table>
<h2 id="schematic">Schematic</h2>
<p>An image of the schematic can be found <a href="circuit(4).png">here</a></p>
<p><img src="file:///c:/Users/johnd/OneDrive/Documents/GitHub/Game-Controller---ECEN-260-Final/circuit.png" alt="test"></p>
<h2 id="test-plan-and-results">Test Plan and Results</h2>
<p>The following test plan provides detailed steps and results to validate the system's functionality:</p>
<table>
<thead>
<tr>
<th>Case</th>
<th>Steps</th>
<th>Expected Result</th>
<th>Observed Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test Case 1: Joystick Movement to the Right</td>
<td>1. Push the joystick to the right (X &gt; 0.8). <br> 2. Observe the object movement on the display. <br> 3. Check the UART output.</td>
<td>Object moves right;<br> &quot;Moving right...&quot; is transmitted.</td>
<td>Object moved right as expected.<br> UART output verified.</td>
</tr>
<tr>
<td>Test Case 2: Joystick Movement to the Left</td>
<td>1. Push the joystick to the left (X &lt; 0.2).<br> 2. Observe the object movement on the display.<br> 3. Check the UART output.</td>
<td>Object moves left;<br> &quot;Moving left...&quot; is transmitted.</td>
<td>Object moved left as expected.<br> UART output verified.</td>
</tr>
<tr>
<td>Test Case 3: Button State Toggle</td>
<td>1. Press the button.<br> 2. Check the state change and UART output.</td>
<td>State toggles;<br> message transmitted (e.g., &quot;Changed state to 1...&quot;).</td>
<td>State toggled as expected.<br> UART output verified.</td>
</tr>
<tr>
<td>Test Case 4: Hitting Wall on each Edge</td>
<td>1. Move the joystick until the object reaches an edge.<br> 2.Observe the UART output.</td>
<td>Message &quot;Hit the wall ...&quot; is displayed.</td>
<td>Message displayed correctly.</td>
</tr>
<tr>
<td>Test Case 5: Button Debounce</td>
<td>1. Press the button rapidly.<br> 2. Check for unintended toggles.</td>
<td>Button press is ignored within the debounce delay.</td>
<td>Debouncing worked as expected.</td>
</tr>
</tbody>
</table>
<h3 id="summary-of-results">Summary of Results</h3>
<p>The system performed as expected across all test cases, demonstrating smooth joystick-controlled movement, accurate state toggling, and proper edge-case handling. Key highlights include:</p>
<p>Joystick movements were accurately mapped to object positions on the display.</p>
<p>Button debounce logic successfully prevented unintended rapid toggles.</p>
<p>UART communication reliably transmitted feedback messages in real-time.</p>
<h2 id="relevant-code">Relevant Code</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_TIM_PeriodElapsedCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span> </span>{ <span class="hljs-comment">// Check which timer triggered this callback</span>
    <span class="hljs-keyword">if</span> (htim == &amp;htim16) <span class="hljs-comment">// if the triggered timer was Timer 16</span>
        { <span class="hljs-keyword">int</span> ADC_RANGE = <span class="hljs-number">4096</span>; <span class="hljs-comment">// set variables</span>

        <span class="hljs-comment">// Start ADC Conversions</span>
        HAL_ADC_Start(&amp;hadc1);
        HAL_ADC_Start(&amp;hadc2);

        <span class="hljs-comment">// Wait for ADC conversions to complete</span>
        HAL_ADC_PollForConversion(&amp;hadc1, HAL_MAX_DELAY);
        HAL_ADC_PollForConversion(&amp;hadc2, HAL_MAX_DELAY);


        <span class="hljs-comment">// Read ADC values</span>
        <span class="hljs-keyword">uint16_t</span> xjoy_measurement = HAL_ADC_GetValue(&amp;hadc1);
        <span class="hljs-keyword">uint16_t</span> yjoy_measurement = HAL_ADC_GetValue(&amp;hadc2);

        <span class="hljs-comment">// Convert ADC levels to a fraction of total</span>
        <span class="hljs-keyword">float</span> xjoy_value = ((<span class="hljs-keyword">float</span>) xjoy_measurement) / ADC_RANGE;
        <span class="hljs-keyword">float</span> yjoy_value = ((<span class="hljs-keyword">float</span>) yjoy_measurement) / ADC_RANGE;

        <span class="hljs-comment">// Movement on screen</span>

        <span class="hljs-keyword">if</span>(xjoy_value &gt; <span class="hljs-number">0.8</span>){
            <span class="hljs-keyword">if</span>(object_x &lt; <span class="hljs-number">75</span>){ <span class="hljs-comment">// set a limit on how far the cursor can move</span>
                object_x = object_x + <span class="hljs-number">5</span>; <span class="hljs-comment">// moves the current x value of the object to the right by 1</span>
                <span class="hljs-built_in">strncpy</span>((<span class="hljs-keyword">char</span>*)response, <span class="hljs-string">"Moving right..."</span>, MAX_MESSAGE_SIZE);
                
            }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-built_in">strncpy</span>((<span class="hljs-keyword">char</span>*)response, <span class="hljs-string">"Hit the wall on the right..."</span>, MAX_MESSAGE_SIZE);
            }
        }
        
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(xjoy_value &lt; <span class="hljs-number">0.2</span>){
            <span class="hljs-keyword">if</span>(object_x &gt;= <span class="hljs-number">0</span>){
                object_x = object_x - <span class="hljs-number">5</span>; <span class="hljs-comment">// moves the current x value of the object to the left by 1</span>
                <span class="hljs-built_in">strncpy</span>((<span class="hljs-keyword">char</span>*)response, <span class="hljs-string">"Moving left..."</span>, MAX_MESSAGE_SIZE);
            }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-built_in">strncpy</span>((<span class="hljs-keyword">char</span>*)response, <span class="hljs-string">"Hit the wall on the left..."</span>, MAX_MESSAGE_SIZE);
            }
        }

        <span class="hljs-keyword">if</span>(yjoy_value &gt; <span class="hljs-number">0.8</span>){
            <span class="hljs-keyword">if</span>(object_y &lt; <span class="hljs-number">5</span>){
                object_y = object_y + <span class="hljs-number">1</span>; <span class="hljs-comment">// moves the current x value of the object down by 1</span>
                <span class="hljs-built_in">strncpy</span>((<span class="hljs-keyword">char</span>*)response, <span class="hljs-string">"Moving down..."</span>, MAX_MESSAGE_SIZE);
                }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-built_in">strncpy</span>((<span class="hljs-keyword">char</span>*)response, <span class="hljs-string">"Hit the wall on the bottom..."</span>, MAX_MESSAGE_SIZE);
            }
        }
        
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(yjoy_value &lt; <span class="hljs-number">0.2</span>){
            <span class="hljs-keyword">if</span>(object_y &gt;= <span class="hljs-number">0</span>){
                object_y = object_y - <span class="hljs-number">1</span>; <span class="hljs-comment">// moves the current x value of the object up by 1</span>
                <span class="hljs-built_in">strncpy</span>((<span class="hljs-keyword">char</span>*)response, <span class="hljs-string">"Moving up..."</span>, MAX_MESSAGE_SIZE);
                
            }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-built_in">strncpy</span>((<span class="hljs-keyword">char</span>*)response, <span class="hljs-string">"Hit the wall on the top..."</span>, MAX_MESSAGE_SIZE);
            }
        }

        GLCD_clear(); <span class="hljs-comment">// clear screen</span>
        GLCD_setCursor(object_x, object_y); <span class="hljs-comment">// moves cursor to new object position</span>
        GLCD_putchar(object_state); <span class="hljs-comment">// places object at the new position</span>


        <span class="hljs-comment">// Send the response message to laptop</span>
        HAL_UART_Transmit(&amp;huart2, response, <span class="hljs-built_in">strlen</span>((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)response), UART_DELAY);

        <span class="hljs-comment">// Zero out message array and response array to get ready for the next message</span>
        <span class="hljs-built_in">memset</span>(message,  <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(message));
        <span class="hljs-built_in">memset</span>(response, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(response));
        buffer_position = <span class="hljs-number">0</span>;
        }

}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_GPIO_EXTI_Callback</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> GPIO_Pin)</span> </span>{
    <span class="hljs-comment">// Check if the interrupt was for the button</span>
    <span class="hljs-keyword">if</span> (GPIO_Pin == BUTTON_PIN) {
        <span class="hljs-keyword">uint32_t</span> current_time = HAL_GetTick(); <span class="hljs-comment">// Get the current system time in ms</span>

        <span class="hljs-comment">// Check if the debounce delay has passed</span>
        <span class="hljs-keyword">if</span> ((current_time - last_button_press) &gt; DEBOUNCE_DELAY) {
            last_button_press = current_time; <span class="hljs-comment">// Update the last press timestamp</span>

            <span class="hljs-comment">// Toggle the object state</span>
            <span class="hljs-keyword">if</span> (object_state == <span class="hljs-number">0</span>) {
                object_state = <span class="hljs-number">1</span>;
                <span class="hljs-built_in">strncpy</span>((<span class="hljs-keyword">char</span>*)response, <span class="hljs-string">"Changed state to 1..."</span>, MAX_MESSAGE_SIZE);
            } <span class="hljs-keyword">else</span> {
                object_state = <span class="hljs-number">0</span>;
                <span class="hljs-built_in">strncpy</span>((<span class="hljs-keyword">char</span>*)response, <span class="hljs-string">"Changed state to 0..."</span>, MAX_MESSAGE_SIZE);
            }

            <span class="hljs-comment">// Send the response message to the laptop</span>
            HAL_UART_Transmit(&amp;huart2, response, <span class="hljs-built_in">strlen</span>((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)response), UART_DELAY);
        }
    }
}
</div></code></pre>
<p>The entire code can be found <a href="main.c">here</a></p>
<h2 id="conclusion">Conclusion</h2>
<p>This project successfully integrates joystick-controlled movement, UART communication, and button-based state toggling into a functional prototype system. The system was rigorously tested for joystick input accuracy, button responsiveness, and edge case handling. Key performance metrics, such as smooth joystick-controlled movement and proper debounce functionality for button presses, were met successfully, ensuring reliable operation. Observed results aligned with expectations across all test cases, confirming the system's stability and usability. By utilizing interrupts, ADC, and UART, the system demonstrates efficient real-time control and feedback mechanisms.</p>
<p>The design offers a foundation for further development into gaming controllers, robotics, or industrial applications. With additional refinements, such as improved error handling and enhanced display capabilities, this system can be transformed into a market-ready product that meets various user needs while considering safety, economic, and global factors.</p>

</body>
</html>
